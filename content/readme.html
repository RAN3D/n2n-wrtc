
<html><head></head><body><h1 id="n2n-wrtc">n2n-wrtc <a href="https://travis-ci.com/RAN3D/n2n-wrtc"><img src="https://travis-ci.com/RAN3D/n2n-wrtc.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a> <a href="https://gitter.im/ran3d/n2n-wrtc"><img src="https://badges.gitter.im/gitterHQ/gitter.png" alt="Gitter chat" style="max-width: 100%;"></a></h1>
<hr />
<p><strong>Keywords:</strong> WebRTC, browser-to-browser communication, overlay networks</p>
<p>Create and manage connections over a network using signaling services and communication wrappers.</p>
<p> <strong>Link</strong> to the <a href="#features">list of features available</a></p>
<p>For the moment a <strong>WebRTC</strong> wrapper is included, but other wrapper can be used following the same API.</p>
<p><strong>NB1:</strong> Build for browsers and Node (v8.12.0+)</p>
<p><strong>NB:</strong> This package is a replacement package for n2n-overlay-wrtc and neighborhood-wrtc
This allows to do the same job but the package is completely rebuilt from scratch for simplicity.</p>
<h2 id="install">Install</h2>
<hr />
<pre><code>npm install --save n2n-wrtc</code></pre><h2 id="usage">Usage</h2>
<hr />
<p>Just add in your index.html:</p>
<pre><code class="js">&lt;script type='text/javascript' src='./node_modules/n2n-wrtc/bin/n2n-wrtc.bundle.min.js'&gt;&lt;/script&gt;</code></pre>
<p>Then the library is available through the name <strong>n2n</strong></p>
<p>In <strong>NodeJs</strong> just do <code>const n2n = require('n2n')</code></p>
<p>Now an example of how to using it (without the signaling server):</p>
<pre><code class="javascript">const N2N = n2n.N2N // get the N2N class

const a = create('a')
const b = create('b')
const c = create('c')

async function start() {
  await b.connect(a)
  await c.connect(b)
  await b.bridgeOI(a.id, c.id)
}

async().then(() =&gt; {
  console.log('B is connected to A')
  console.log('C is connected to B')
  console.log('A is connected to C using B as forwarding peer.')
})

function create(id) {
  return new N2N({
    n2n: {
      id
    },
    socket: {
      trickle: true,
      moc: true
    }
  })
}</code></pre>
<p>Using the signaling server you can just do <code>npm run signaling</code> and put <code>signaling: {room: 'myroom', address: 'http://localhost:5555'}</code> and then call <code>a.connect()</code> and <code>b.connect()</code> to connect b to a.</p>
<h2 id="neighborhood">Neighborhood</h2>
<hr />
<p>Project that aims to ease the WebRTC connection establishment process. Among others, it alleviates the need to know which socket produced which offer. It also reuses existing connections instead of establishing new ones, when this is possible. It aims to be part of network protocols that build overlay networks and to provide them logical arcs - using identifiers - instead of channels. Finally, it is designed to handle multiple protocols, for they may share identical arcs. For instance, consider several applications embedded in a single web page, some of them are connected to a same peer. Instead of working completely on their own, these applications will share the same channel. The neighborhood-wrtc module will redirect the messages to the right applications.</p>
<h3 id="principle">Principle</h3>
<p align="center">
<img src="./assets/img/notsharing.png#center" style="max-width: 100%;">
</p>

<p>Three peer-to-peer applications <code>8O</code>, <code>:|</code> and <code>&gt;_&lt;</code> run in a same
tab of a WebRTC-compatible browser. When they want to connect to their
respective remote counterpart, the browser must establish 3 WebRTC connections,
for they do not share any information between each other.</p>
<p align="center">
<img src="./assets/img/sharing.png#center" style="max-width: 100%;">
</p>


<p>Using this module to create WebRTC connections, they can share it and messages
will be automatically redirected to corresponding applications. In this example,
instead of establishing and maintaining 3 distinct connections -- which may be
costly in terms of time and bandwidth -- neighborhood-wrtc only establish 1. The
connection is destroyed only if the 3 applications remove it.</p>
<h2 id="neighborhood-to-neighborhood--n2n-">Neighborhood-to-Neighborhood (N2N)</h2>
<hr />
<p>This project aims to ease the creation of overlay networks on top of WebRTC. Additional WebRTC-specific constraints make such projects more difficult than they should be. For instance, establishing a connection requires a round-trip of "offers". Such messages usually transit a dedicated signaling server. The peers of this project still require a signaling server for their entrance in the network. Afterwards, peers become signaling servers too, i.e., they mediate connections between their direct neighbors.</p>
<p>This module divides the entering arcs (inview) from the outgoing arcs (outview).</p>
<p>The way connections are handled are left to the discretion of overlay protocols built on top of this module. A peer with two neighbors can ask to one of them to connect to the other. Several overlay network protocols use neighbor-to-neighbor interactions to converge to a topology exposing the desired properties.</p>
<h3 id="principle">Principle</h3>
<p align="center">
<img src="./assets/img/signal.png#center" style="max-width: 100%;">
</p>

<p>There exists a network comprising at least Peer <code>:|</code>. Peer <code>:]</code> wants to
join this network. <code>:|</code> knows it and opens an access to the network thanks
to a signaling server. The signaling server is in charge of transmitting the
necessary WebRTC data from both sides. The figure shows this protocol with the
1-&gt;2-&gt;3-&gt;4 steps that can be repeated many times depending on network
configurations. If the protocol is successful, it creates a direct
browser-to-browser connection from <code>:]</code> to <code>:|</code>.</p>
<p align="center">
<img src="./assets/img/bridge.png#center" style="max-width: 100%;">
</p>

<p>Peers already in the network do not need to use a signaling server to establish
connections, for each of them can act as a signaling server, i.e. as a bridge
from a neighbor to another. In the figure, <code>:3</code>, <code>:]</code>, and <code>:|</code> are
in the network. <code>:3</code> can establish a WebRTC connection to <code>:|</code> using
<code>:]</code>. Such neighbor-to-neighbor connections are common in distributed
peer-sampling protocols.</p>
<h2 id="overview-of-available-functionalities">Overview of available functionalities <a name="features"></a></h2>
<hr />
<ul>
<li><input checked="" disabled="" type="checkbox"> Create the API (api for neighborhood, signaling services, n2n and sockets)</li>
<li><input checked="" disabled="" type="checkbox"> Create WebRTC Wrapper using (<a href="https://github.com/feross/simple-peer">simple-peer</a>)</li>
<li><input disabled="" type="checkbox"> Create Bluetooth Wrapper using (<a href="http://sabertooth-io.github.io/">sabertooth</a>)</li>
<li><input checked="" disabled="" type="checkbox"> <strong>Offline signaling</strong> allowing to do <code>a.connect(b)</code></li>
<li><input checked="" disabled="" type="checkbox"> <strong>Signaling server</strong> for online signaling<ul>
<li><code>npm run signaling</code> or</li>
<li><code>require('n2n-wrtc/lib/signaling/server').server()</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>Online signaling</strong> allowing to do <code>a.connect()</code> using a signaling server</li>
<li><input checked="" disabled="" type="checkbox"> <strong>Get a list of all neighbours (not locked)</strong>:  <ul>
<li><code>a.getNeighbours()</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>Get a list of all neighbours (even if locked)</strong> <code>a.getAllNeighbours(true)</code></li>
<li><input checked="" disabled="" type="checkbox"> <strong>Get a list of all neighbours ids (locked/ not locked)</strong> (outview):<ul>
<li><code>a.getNeighboursIds([true/false])</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>Get only inview ids</strong>:<ul>
<li><code>a.getNeighboursInview()</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>Get only outview ids (not locked)</strong>: <code>a.getNeighboursOutview()</code></li>
<li><input checked="" disabled="" type="checkbox"> <strong>Send</strong> a message over Unicast and the received message will be emit on the specified event (here: 'receive'):<ul>
<li><code>a.send('receive', b.id, 'meow');</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>Listen on incoming messages</strong>:<ul>
<li><code>b.on('receive', (id, message) =&gt; ...);</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Create the internal signaling service:<ul>
<li>Allow to forward offers from an inview neighbour to an outview neighbour</li>
<li>After connection new offers are transmitted by message (usefull for re-negociation)</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Create from -&gt; to connections allowing to do: <code>a.connectFromUs(b.id)</code><ul>
<li><strong>b.id need to be in our outview</strong></li>
<li>It means that it increments our outview, not the inview of the neighbor</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Create a Direct signaling service</li>
<li><input checked="" disabled="" type="checkbox"> Create to -&gt; from connections <code>a.connectToUs(b.id)</code><ul>
<li><strong>b.id need to be in our outview</strong></li>
<li>It means that it does the same thing than from -&gt; to but from the neighbor: <code>a.connectFrom(b.id)</code></li>
<li>If the connection does not exist, create the connection using the direct signaling service</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <code>a.connect4u(&lt;id&gt;, &lt;id&gt;)</code> choose for you what kind of method to apply for performing the connection for you.<ul>
<li>Be carefull, if a bridge is done, it is a bridge where from is in your inview and dest is in your outview.</li>
<li>For more choices, see <code>bridgeOO(...)</code> and <code>bridgeOI(...)</code> methods.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Ice Re-negociation, when a peer is connected, new offers are transferred using the connection.</li>
<li><input disabled="" type="checkbox"> Encapsulate each message sent for distinguish admin messages from application messages</li>
<li><input disabled="" type="checkbox"> Minimize the encapsulation</li>
<li><input disabled="" type="checkbox"> Control the size of the object sent and create a mechanism to handle bigger files (chunkification)</li>
</ul>
<h2 id="turn-and-stun-servers--for-tests-purposes-only-">Turn and Stun servers (for tests purposes only)</h2>
<hr />
<p>For production purposes see (<a href="https://www.twilio.com/stun-turn">https://www.twilio.com/stun-turn</a>)</p>
<ul>
<li><p>a stun server is available through <code>node-stun-server</code> <a href="https://github.com/enobufs/stun">node-stun</a></p>
<ul>
<li>check the node-stun.ini in tests/stun folder.<pre><code class="javascript">const iceServers = {
url: 'stun:127.0.0.1:3478'
}</code></pre>
</li>
</ul>
</li>
<li><p>a turn server is available through a Dockerfile</p>
<ul>
<li>check the Dockerfile in the tests/turn folder.<pre><code class="javascript">const iceServers = {
urls: 'turn:127.0.0.1:3478?transport=udp'
username: 'username',
password: 'password'
}</code></pre>
</li>
</ul>
</li>
</ul>
</body></html>