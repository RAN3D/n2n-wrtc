
<html><head></head><body><h1 id="n2n-wrtc">n2n-wrtc <a href="https://travis-ci.com/RAN3D/n2n-wrtc"><img src="https://travis-ci.com/RAN3D/n2n-wrtc.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a> <a href="https://gitter.im/ran3d/n2n-wrtc"><img src="https://badges.gitter.im/gitterHQ/gitter.png" alt="Gitter chat" style="max-width: 100%;"></a></h1>
<hr />
<p><strong>Keywords:</strong> WebRTC, browser-to-browser communication, overlay networks</p>
<p>Create and manage connections over a network using signaling services and communication wrappers.</p>
<p> <strong>Link</strong> to the <a href="#features">list of features available</a></p>
<p>For the moment a <strong>WebRTC</strong> wrapper is included, but other wrapper can be used following the same API.</p>
<p><strong>NB1:</strong> Build for browsers and Node (v8.12.0+)</p>
<p><strong>NB:</strong> This package is a replacement package for n2n-overlay-wrtc and neighborhood-wrtc
This allows to do the same job but the package is completely rebuilt from scratch for simplicity.</p>
<h2 id="install">Install</h2>
<hr />
<pre><code>npm install --save n2n-wrtc
</code></pre><h2 id="usage">Usage</h2>
<hr />
<p>Just add in your index.html:</p>
<pre><code class="lang-js">&lt;script type='text/javascript' src='./node_modules/n2n-wrtc/bin/n2n-wrtc.bundle.min.js'&gt;&lt;/script&gt;
</code></pre>
<p>Then the library is available through the name <strong>n2n</strong></p>
<p>In <strong>NodeJs</strong> just do <code>const n2n = require('n2n')</code></p>
<p>Now an example of how to using it (without the signaling server):</p>
<pre><code class="lang-javascript">const N2N = n2n.N2N // get the N2N class

const a = create('a')
const b = create('b')
const c = create('c')

async function start() {
  await b.connect(a)
  await c.connect(b)
  await b.bridgeOI(a.id, c.id)
}

async().then(() =&gt; {
  console.log('B is connected to A')
  console.log('C is connected to B')
  console.log('A is connected to C using B as forwarding peer.')
})

function create(id) {
  return new N2N({
    n2n: {
      id
    },
    socket: {
      trickle: true,
      moc: true
    }
  })
}
</code></pre>
<p>Using the signaling server you can just do <code>npm run signaling</code> and put <code>signaling: {room: 'myroom', address: 'http://localhost:5555'}</code> and then call <code>a.connect()</code> and <code>b.connect()</code> to connect b to a.</p>
<h2 id="neighborhood">Neighborhood</h2>
<hr />
<p>Project that aims to ease the WebRTC connection establishment process. Among others, it alleviates the need to know which socket produced which offer. It also reuses existing connections instead of establishing new ones, when this is possible. It aims to be part of network protocols that build overlay networks and to provide them logical arcs - using identifiers - instead of channels. Finally, it is designed to handle multiple protocols, for they may share identical arcs. For instance, consider several applications embedded in a single web page, some of them are connected to a same peer. Instead of working completely on their own, these applications will share the same channel. The neighborhood-wrtc module will redirect the messages to the right applications.</p>
<h3 id="principle">Principle</h3>
<p align="center">
<img src="./assets/img/notsharing.png#center" style="max-width: 100%;">
</p>

<p>Three peer-to-peer applications <code>8O</code>, <code>:|</code> and <code>&gt;_&lt;</code> run in a same
tab of a WebRTC-compatible browser. When they want to connect to their
respective remote counterpart, the browser must establish 3 WebRTC connections,
for they do not share any information between each other.</p>
<p align="center">
<img src="./assets/img/sharing.png#center" style="max-width: 100%;">
</p>


<p>Using this module to create WebRTC connections, they can share it and messages
will be automatically redirected to corresponding applications. In this example,
instead of establishing and maintaining 3 distinct connections -- which may be
costly in terms of time and bandwidth -- neighborhood-wrtc only establish 1. The
connection is destroyed only if the 3 applications remove it.</p>
<h2 id="neighborhood-to-neighborhood--n2n-">Neighborhood-to-Neighborhood (N2N)</h2>
<hr />
<p>This project aims to ease the creation of overlay networks on top of WebRTC. Additional WebRTC-specific constraints make such projects more difficult than they should be. For instance, establishing a connection requires a round-trip of "offers". Such messages usually transit a dedicated signaling server. The peers of this project still require a signaling server for their entrance in the network. Afterwards, peers become signaling servers too, i.e., they mediate connections between their direct neighbors.</p>
<p>This module divides the entering arcs (inview) from the outgoing arcs (outview).</p>
<p>The way connections are handled are left to the discretion of overlay protocols built on top of this module. A peer with two neighbors can ask to one of them to connect to the other. Several overlay network protocols use neighbor-to-neighbor interactions to converge to a topology exposing the desired properties.</p>
<h3 id="principle">Principle</h3>
<p align="center">
<img src="./assets/img/signal.png#center" style="max-width: 100%;">
</p>

<p>There exists a network comprising at least Peer <code>:|</code>. Peer <code>:]</code> wants to
join this network. <code>:|</code> knows it and opens an access to the network thanks
to a signaling server. The signaling server is in charge of transmitting the
necessary WebRTC data from both sides. The figure shows this protocol with the
1-&gt;2-&gt;3-&gt;4 steps that can be repeated many times depending on network
configurations. If the protocol is successful, it creates a direct
browser-to-browser connection from <code>:]</code> to <code>:|</code>.</p>
<p align="center">
<img src="./assets/img/bridge.png#center" style="max-width: 100%;">
</p>

<p>Peers already in the network do not need to use a signaling server to establish
connections, for each of them can act as a signaling server, i.e. as a bridge
from a neighbor to another. In the figure, <code>:3</code>, <code>:]</code>, and <code>:|</code> are
in the network. <code>:3</code> can establish a WebRTC connection to <code>:|</code> using
<code>:]</code>. Such neighbor-to-neighbor connections are common in distributed
peer-sampling protocols.</p>
<h2 id="overview-of-available-functionalities">Overview of available functionalities <a name="features"></a></h2>
<hr />
<ul class="docma task-list">
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create the API (api for neighborhood, signaling services, n2n and sockets)</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create WebRTC Wrapper using (<a href="https://github.com/feross/simple-peer">simple-peer</a>)</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Create Bluetooth Wrapper using (<a href="http://sabertooth-io.github.io/">sabertooth</a>)</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Offline signaling</strong> allowing to do <code>a.connect(b)</code></li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Signaling server</strong> for online signaling<ul>
<li><code>npm run signaling</code> or</li>
<li><code>require('n2n-wrtc/lib/signaling/server').server()</code></li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Online signaling</strong> allowing to do <code>a.connect()</code> using a signaling server</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Get a list of all neighbours (not locked)</strong>:  <ul>
<li><code>a.getNeighbours()</code></li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Get a list of all neighbours (even if locked)</strong> <code>a.getAllNeighbours(true)</code></li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Get a list of all neighbours ids (locked/ not locked)</strong> (outview):<ul>
<li><code>a.getNeighboursIds([true/false])</code></li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Get only inview ids</strong>:<ul>
<li><code>a.getNeighboursInview()</code></li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Get only outview ids (not locked)</strong>: <code>a.getNeighboursOutview()</code></li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Send</strong> a message over Unicast and the received message will be emit on the specified event (here: 'receive'):<ul>
<li><code>a.send('receive', b.id, 'meow');</code></li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<strong>Listen on incoming messages</strong>:<ul>
<li><code>b.on('receive', (id, message) =&gt; ...);</code></li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create the internal signaling service:<ul>
<li>Allow to forward offers from an inview neighbour to an outview neighbour</li>
<li>After connection new offers are transmitted by message (usefull for re-negociation)</li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create from -&gt; to connections allowing to do: <code>a.connectFromUs(b.id)</code><ul>
<li><strong>b.id need to be in our outview</strong></li>
<li>It means that it increments our outview, not the inview of the neighbor</li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create a Direct signaling service</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create to -&gt; from connections <code>a.connectToUs(b.id)</code><ul>
<li><strong>b.id need to be in our outview</strong></li>
<li>It means that it does the same thing than from -&gt; to but from the neighbor: <code>a.connectFrom(b.id)</code></li>
<li>If the connection does not exist, create the connection using the direct signaling service</li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;<code>a.connect4u(&lt;id&gt;, &lt;id&gt;)</code> choose for you what kind of method to apply for performing the connection for you.<ul>
<li>Be carefull, if a bridge is done, it is a bridge where from is in your inview and dest is in your outview.</li>
<li>For more choices, see <code>bridgeOO(...)</code> and <code>bridgeOI(...)</code> methods.</li>
</ul>
</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Ice Re-negociation, when a peer is connected, new offers are transferred using the connection.</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Encapsulate each message sent for distinguish admin messages from application messages</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Minimize the encapsulation</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Control the size of the object sent and create a mechanism to handle bigger files (chunkification)</li>
</ul>
</body></html>