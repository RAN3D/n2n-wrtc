
<html><head></head><body><h1 id="n2n-wrtc">n2n-wrtc <a href="https://travis-ci.com/RAN3D/n2n-wrtc"><img src="https://travis-ci.com/RAN3D/n2n-wrtc.svg?branch=master" alt="Build Status" style="max-width: 100%;"></a></h1>
<hr />
<p><strong>Keywords:</strong> WebRTC, browser-to-browser communication, overlay networks</p>
<p>Create and manage connections over a network using signaling services and communication wrappers.</p>
<p>For the moment a WebRTC and a Bluetooth wrapper is included, but other wrapper can be used following the same API.</p>
<p><strong>NB1:</strong> Build for browsers and Node (v8.11.1+)</p>
<p><strong>NB:</strong> This package is a replacement package for n2n-overlay-wrtc and neighborhood-wrtc
This allows to do the same job but the package is completely rebuilt from scratch for simplicity.</p>
<h2 id="install">Install</h2>
<hr />
<pre><code>npm install --save n2n-wrtc
</code></pre><h2 id="usage">Usage</h2>
<hr />
<p>In the browser the library is available through the name n2n</p>
<p>In NodeJs just do <code>const n2n = require('n2n')</code></p>
<h2 id="neighborhood">Neighborhood</h2>
<hr />
<p>Project that aims to ease the WebRTC connection establishment process. Among others, it alleviates the need to know which socket produced which offer. It also reuses existing connections instead of establishing new ones, when this is possible. It aims to be part of network protocols that build overlay networks and to provide them logical arcs - using identifiers - instead of channels. Finally, it is designed to handle multiple protocols, for they may share identical arcs. For instance, consider several applications embedded in a single web page, some of them are connected to a same peer. Instead of working completely on their own, these applications will share the same channel. The neighborhood-wrtc module will redirect the messages to the right applications.</p>
<h3 id="principle">Principle</h3>
<p align="center">
<img src="./assets/img/notsharing.png#center" style="max-width: 100%;">
</p>

<p>Three peer-to-peer applications <code>8O</code>, <code>:|</code> and <code>&gt;_&lt;</code> run in a same
tab of a WebRTC-compatible browser. When they want to connect to their
respective remote counterpart, the browser must establish 3 WebRTC connections,
for they do not share any information between each other.</p>
<p align="center">
<img src="./assets/img/sharing.png#center" style="max-width: 100%;">
</p>


<p>Using this module to create WebRTC connections, they can share it and messages
will be automatically redirected to corresponding applications. In this example,
instead of establishing and maintaining 3 distinct connections -- which may be
costly in terms of time and bandwidth -- neighborhood-wrtc only establish 1. The
connection is destroyed only if the 3 applications remove it.</p>
<h2 id="neighborhood-to-neighborhood--n2n-">Neighborhood-to-Neighborhood (N2N)</h2>
<hr />
<p>This project aims to ease the creation of overlay networks on top of WebRTC. Additional WebRTC-specific constraints make such projects more difficult than they should be. For instance, establishing a connection requires a round-trip of "offers". Such messages usually transit a dedicated signaling server. The peers of this project still require a signaling server for their entrance in the network. Afterwards, peers become signaling servers too, i.e., they mediate connections between their direct neighbors.</p>
<p>This module divides the entering arcs (inview) from the outgoing arcs (outview).</p>
<p>The way connections are handled are left to the discretion of overlay protocols built on top of this module. A peer with two neighbors can ask to one of them to connect to the other. Several overlay network protocols use neighbor-to-neighbor interactions to converge to a topology exposing the desired properties.</p>
<h3 id="principle">Principle</h3>
<p align="center">
<img src="./assets/img/signal.png#center" style="max-width: 100%;">
</p>

<p>There exists a network comprising at least Peer <code>:|</code>. Peer <code>:]</code> wants to
join this network. <code>:|</code> knows it and opens an access to the network thanks
to a signaling server. The signaling server is in charge of transmitting the
necessary WebRTC data from both sides. The figure shows this protocol with the
1-&gt;2-&gt;3-&gt;4 steps that can be repeated many times depending on network
configurations. If the protocol is successful, it creates a direct
browser-to-browser connection from <code>:]</code> to <code>:|</code>.</p>
<p align="center">
<img src="./assets/img/bridge.png#center" style="max-width: 100%;">
</p>

<p>Peers already in the network do not need to use a signaling server to establish
connections, for each of them can act as a signaling server, i.e. as a bridge
from a neighbor to another. In the figure, <code>:3</code>, <code>:]</code>, and <code>:|</code> are
in the network. <code>:3</code> can establish a WebRTC connection to <code>:|</code> using
<code>:]</code>. Such neighbor-to-neighbor connections are common in distributed
peer-sampling protocols.</p>
<h2 id="overview-of-available-functionalities">Overview of available functionalities</h2>
<hr />
<ul class="docma task-list">
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create the API (api for neighborhood, signaling services, n2n and sockets)</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create WebRTC Wrapper using (<a href="https://github.com/feross/simple-peer">simple-peer</a>)</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Create Bluetooth Wrapper using (<a href="http://sabertooth-io.github.io/">sabertooth</a>)</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Create the Signaling service for the very first connection (the entrance)</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Offline signaling allowing to do <code>a.connect(b)</code></li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Implement a signaling service (<code>npm run signaling</code> or <code>require('n2n-wrtc/lib/signaling/server').server()</code>)</li>
<li class="docma task-item"><input type="checkbox" disabled="" checked=""> &nbsp;Online signaling allowing to do <code>a.connect()</code> using a signaling server</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Create the internal signaling service</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Create bridge connections</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Create from -&gt; to connections</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Create to -&gt; from connections</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Encapsulate each message sent for distinguish admin messages from application messages</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Minimize the encapsulation</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Control the size of the object sent and create a mechanism to handle bigger files (chunkification)</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Allows each method to be customizable</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;(Optionnal) Allows for hooks before sending and after sending messages</li>
<li class="docma task-item"><input type="checkbox" disabled=""> &nbsp;Connection/Disconnection/MessageSendFunction bufferization in N2N module.</li>
</ul>
</body></html>